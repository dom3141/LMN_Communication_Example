/* Copyright 2015 Dominik Lüthe
 * Labor Datentechnik, Ostfalia Hochschule Braunschweig/Wolfenbüttel
 *
 * This file is part of LMN Communication Example for Smart Meters
 *
 * LMN Communication Example for Smart Meters is free software:
 * you can redistribute it and/or modify it under the terms of
 * the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LMN Communication Example for Smart Meters is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LMN Communication Example for Smart Meters. If not,
 * see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include "hdlc.h"
#include "fakeRS232.h"
#include "test.h"
#include "testZaehler.h"
#include <time.h>
#include <sys/time.h>
#include "RS232.h"

using namespace std;
#if TEST
//#include <Windows.h>
#include <iostream>
#endif

extern int global_debug;
extern int global_log;
extern FILE *logfile;
extern int fileOpened;

void fakeRS232DataRequest(unsigned char destAddr, unsigned char sourceAddr,
		protocolSelector protSel, unsigned char *payload, int payloadLength,
		func_ptr callback) {

	unsigned char broadcastReply[] = { 0x7E, 0xA0, 0x2B, 0x02, 0x03, 0x74, 0x03,
			0x13, 0x25, 0x19, 0x3A, 0x19, 0x0A, 0x01, 0x45, 0x4D, 0x48, 0x00,
			0x00, 0x4A, 0xF1, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x45,
			0x4D, 0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFD, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0xB3, 0x88, 0x7E };

	unsigned char broadcastReply2[] = { 0x7E, 0xA0, 0x2B, 0x02, 0x03, 0xA6,
			0x03, 0x13, 0x92, 0x23, 0x53, 0x0B, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01,
			0x45, 0x4D, 0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFE, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x9B, 0x83, 0x7E };

	unsigned char broadcastReply3[] = { 0x7E, 0xA0, 0x2B, 0x02, 0x03, 0x98,
			0x03, 0x13, 0x27, 0xB5, 0x4C, 0x04, 0x11, 0x22, 0x33, 0x44, 0x55,
			0x66, 0x77, 0x88, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x01,
			0x45, 0x4D, 0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFF, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0xC8, 0x61, 0x7E };

	unsigned char broadcastReplyDreimal[] = { 0x7E, 0xA0, 0x2B, 0x02, 0x03,
			0x74, 0x03, 0x13, 0x25, 0x19, 0x3A, 0x19, 0x0A, 0x01, 0x45, 0x4D,
			0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x0A,
			0x01, 0x45, 0x4D, 0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFD, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0xB3, 0x88, 0x7E, 0x7E, 0xA0, 0x2B, 0x02,
			0x03, 0x98, 0x03, 0x13, 0x27, 0xB5, 0x4C, 0x04, 0x11, 0x22, 0x33,
			0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0A, 0x01, 0x45, 0x4D, 0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFF, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x61, 0x7E, 0x7E, 0xA0, 0x2B,
			0x02, 0x03, 0xA6, 0x03, 0x13, 0x92, 0x23, 0x53, 0x0B, 0xAA, 0xBB,
			0xCC, 0xDD, 0xEE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
			0x00, 0x0A, 0x01, 0x45, 0x4D, 0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFE,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x83, 0x7E };

	unsigned char smlMessage[] = { 0x7E, 0xA0, 0xB3, 0x02, 0x07, 0x74, 0x07,
			0x30, 0x7A, 0x79, 0x1B, 0x1B, 0x1B, 0x1B, 0x01, 0x01, 0x01, 0x01,
			0x76, 0x02, 0x35, 0x62, 0x00, 0x62, 0x00, 0x72, 0x63, 0x01, 0x01,
			0x76, 0x01, 0x0B, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
			0x09, 0x0A, 0x02, 0x30, 0x0B, 0x0A, 0x01, 0x45, 0x4D, 0x48, 0x00,
			0x00, 0x4A, 0xF1, 0xFD, 0x72, 0x62, 0x01, 0x64, 0x1C, 0xB0, 0xA8,
			0x01, 0x63, 0x9F, 0x2E, 0x00, 0x76, 0x02, 0x36, 0x62, 0x00, 0x62,
			0x00, 0x72, 0x63, 0x05, 0x01, 0x73, 0x0B, 0x0A, 0x01, 0x45, 0x4D,
			0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFD, 0x73, 0x0A, 0x01, 0x00, 0x01,
			0x08, 0x00, 0xFF, 0x80, 0x02, 0x00, 0x03, 0x00, 0x01, 0x03, 0x00,
			0x02, 0x73, 0x0A, 0x01, 0x00, 0x01, 0x08, 0x00, 0xFF, 0x80, 0x02,
			0x00, 0x01, 0x72, 0x73, 0x03, 0x00, 0x01, 0x72, 0x62, 0x01, 0x07,
			0x01, 0x00, 0x01, 0x08, 0x00, 0xFF, 0x01, 0x73, 0x03, 0x00, 0x02,
			0x72, 0x62, 0x01, 0x64, 0x2A, 0x3F, 0x4E, 0x01, 0x63, 0xAE, 0xAF,
			0x00, 0x76, 0x02, 0x37, 0x62, 0x00, 0x62, 0x00, 0x72, 0x63, 0x02,
			0x01, 0x71, 0x01, 0x63, 0x4F, 0xF8, 0x00, 0x00, 0x00, 0x1B, 0x1B,
			0x1B, 0x1B, 0x1A, 0x02, 0xB2, 0xEB, 0x0A, 0x9A, 0x7E };

	unsigned char realSml[] = { 0x1B, 0x1B, 0x1B, 0x1B, 0x01, 0x01, 0x01, 0x01,
			0x76, 0x05, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x62, 0x00, 0x72,
			0x63, 0x01, 0x01, 0x76, 0x01, 0x0B, 0x0A, 0x01, 0x45, 0x4D, 0x48,
			0x00, 0x00, 0x4A, 0xF1, 0xFD, 0x02, 0x30, 0x0B, 0x0A, 0x01, 0x45,
			0x4D, 0x48, 0x00, 0x00, 0x4A, 0xF1, 0xFD, 0x72, 0x62, 0x01, 0x65,
			0x01, 0x47, 0x1E, 0x9E, 0x01, 0x63, 0xFD, 0x2E, 0x00, 0x76, 0x05,
			0x00, 0x00, 0x00, 0x01, 0x62, 0x00, 0x62, 0x00, 0x72, 0x63, 0x05,
			0x01, 0x73, 0x0B, 0x0A, 0x01, 0x45, 0x4D, 0x48, 0x00, 0x00, 0x4A,
			0xF1, 0xFD, 0x73, 0x0A, 0x01, 0x00, 0x01, 0x08, 0x00, 0xFF, 0x80,
			0x02, 0x00, 0x03, 0x00, 0x01, 0x03, 0x00, 0x02, 0x73, 0x0A, 0x01,
			0x00, 0x01, 0x08, 0x00, 0xFF, 0x80, 0x02, 0x00, 0x01, 0x72, 0x73,
			0x03, 0x00, 0x01, 0x72, 0x62, 0x01, 0x07, 0x01, 0x00, 0x01, 0x08,
			0x00, 0xFF, 0x01, 0x73, 0x03, 0x00, 0x02, 0x72, 0x62, 0x01, 0x64,
			0x36, 0xCF, 0xE9, 0x01, 0x63, 0xF9, 0xE3, 0x00, 0x76, 0x05, 0x00,
			0x00, 0x00, 0x02, 0x62, 0x00, 0x62, 0x00, 0x72, 0x63, 0x02, 0x01,
			0x71, 0x01, 0x63, 0x39, 0xB3, 0x00, 0x1B, 0x1B, 0x1B, 0x1B, 0x1A,
			0x00, 0xF2, 0xD2 };

	unsigned char receiveNotReady[] = { 0x7E, 0xA0, 0x09, 0x02, 0x07, 0x74,
			0x07, 0x35, 0xAB, 0xC5, 0x7E };

	unsigned char receiveReady[] = { 0x7E, 0xA0, 0x09, 0x02, 0x07, 0x74, 0x07,
			0x31, 0x8F, 0x83, 0x7E };

	int receivedBytes = 0;
	char debugString[25000], tempString[25000];

	bzero((char *) &debugString, 25000);
	bzero((char *) &tempString, 25000);

	timeval curTime;
	int milliSeconds;
	unsigned char debugDestAddr = (payload[3] >> 1) & 0xFF;
	unsigned char debugSourceAddr = (payload[5] >> 1) & 0xFF;
	unsigned char debugProtSel =
			static_cast<protocolSelector>((payload[4] & 0xF) >> 1);
	unsigned char debugControlField = payload[7] & 0xFF;
	gettimeofday(&curTime, NULL);
	milliSeconds = curTime.tv_usec / 1000;
	sprintf(tempString,
			"\nSEND DATA: [TIME]=%06d.%03d [DST]=0x%02X [SRC]=0x%02X [PTC]=",
			(int) (time(NULL) & 0x0EFFFF), milliSeconds, debugDestAddr,
			debugSourceAddr);
	strcat(debugString, tempString);

	if (debugDestAddr == 0x7F) {
		if ((debugProtSel & 0xFF) == 0x1) {
			//broadcast = 1;
			sprintf(tempString, "BROADCAST");
		}
		if ((debugProtSel & 0xFF) == 0x2) {
			//recall = 1;
			sprintf(tempString, "RECALL");
		}

	} else {
		switch (debugProtSel & 0xFF) {
		case 0x1:
			sprintf(tempString, "TLS_SML_COSEM");
			break;
		case 0x2:
			sprintf(tempString, "TLS");
			break;
		case 0x3:
			sprintf(tempString, "SML_COSEM");
			break;
		case 0x4:
			sprintf(tempString, "SML_EDL");
			break;
		case 0x5:
			sprintf(tempString, "SML_SYM");
			break;
		case 0x6:
			sprintf(tempString, "SYM_HDLC");
			break;
		case 0x7:
			sprintf(tempString, "TLS_SML_EDL");
			break;
		case 0x8:
			sprintf(tempString, "TLS_SML_SYM");
			break;
		default:
			sprintf(tempString, "SELECTOR_ERROR");
			break;
		}
	}
	strcat(debugString, tempString);
	sprintf(tempString, " [CTR]=");
	strcat(debugString, tempString);
	if (((debugControlField & 0xFF) & 0x1) == 0x00)
		sprintf(tempString, "I");
	if (((debugControlField & 0xFF) & 0xF) == 0x01)
		sprintf(tempString, "RR");
	if (((debugControlField & 0xFF) & 0xF) == 0x05)
		sprintf(tempString, "RNR");
	if (((debugControlField & 0xFF) & 0xEF) == 0x83)
		sprintf(tempString, "SNRM");
	if (((debugControlField & 0xFF) & 0xEF) == 0x43)
		sprintf(tempString, "DISC");
	if (((debugControlField & 0xFF) & 0xEF) == 0x63)
		sprintf(tempString, "UA");
	if (((debugControlField & 0xFF) & 0xEF) == 0x0F)
		sprintf(tempString, "DM");
	if (((debugControlField & 0xFF) & 0xEF) == 0x87)
		sprintf(tempString, "FRMR");
	if (((debugControlField & 0xFF) & 0xEF) == 0x03)
		sprintf(tempString, "UI");
	strcat(debugString, tempString);
	sprintf(tempString, "\n");
	strcat(debugString, tempString);

	for (int i = 0; i < payloadLength; i++) {
		sprintf(tempString, "0x%02X ", payload[i]);
		strcat(debugString, tempString);
		if (i != 0 && (i + 1) % 16 == 0) {
			sprintf(tempString, "\n");
			strcat(debugString, tempString);
		}
	}

	if (payload[3] == 0xFE) {
		if ((payloadLength < 25) || (payload[11] != 0x00)) { //Broadcast Reply!!!!

			for (int i = 0; i < sizeof(broadcastReplyDreimal); i++) {
				payload[i] = broadcastReplyDreimal[i];
				payloadLength = sizeof(broadcastReplyDreimal);

			}

		} else {
			payloadLength = -1;
		}

	} else {

		TestZaehler counter = TestZaehler();

		if (counter.zaehler < 2) {

			for (int i = 0; i < sizeof(smlMessage); i++)
				payload[i] = smlMessage[i];
			payloadLength = sizeof(smlMessage);

		}

		else if (counter.zaehler >= 2 && counter.zaehler < 5) { //RNR

			for (int i = 0; i < sizeof(receiveNotReady); i++)
				payload[i] = receiveNotReady[i];
			payloadLength = sizeof(receiveNotReady);

		}

		else if (counter.zaehler == 5) { //RR

			for (int i = 0; i < sizeof(receiveReady); i++)
				payload[i] = receiveReady[i];
			payloadLength = sizeof(receiveReady);

		}

		else if (counter.zaehler > 5) { //SML

			for (int i = 0; i < sizeof(smlMessage); i++)
				payload[i] = smlMessage[i];
			payloadLength = sizeof(smlMessage);

		}

	}

	usleep(750 * 1000);

	gettimeofday(&curTime, NULL);
	milliSeconds = curTime.tv_usec / 1000;

	if (payloadLength <= 0) {
		sprintf(tempString, "\n\nRECEIVE DATA: [TIME]=%06d.%03d ",
				(int) (time(NULL) & 0x0EFFFF), milliSeconds);
		strcat(debugString, tempString);
		sprintf(tempString, "******* NO REPLY *******");
		strcat(debugString, tempString);
		sprintf(tempString,
				"\n\n-------------------------------------------------------------------------------\n");
		strcat(debugString, tempString);
	} else if (payload[0] != 0x7E || payload[payloadLength - 1] != 0x7E) {
		sprintf(tempString, "\n\nRECEIVE DATA: [TIME]=%06d.%03d ",
				(int) (time(NULL) & 0x0EFFFF), milliSeconds);
		strcat(debugString, tempString);
		sprintf(tempString, "******* FRAME ERROR *******\n");
		strcat(debugString, tempString);
		for (int i = 0; i < payloadLength; i++) {
			sprintf(tempString, "0x%02X ", payload[i]);
			strcat(debugString, tempString);
			if (i != 0 && (i + 1) % 16 == 0) {
				sprintf(tempString, "\n");
				strcat(debugString, tempString);
			}
		}
		sprintf(tempString,
				"\n\n-------------------------------------------------------------------------------\n");
		strcat(debugString, tempString);
	}

	if (global_debug != 0)
		printf(debugString);
	if (global_log != 0) {
		while (fileOpened == 0)
			;
		fprintf(logfile, debugString);
		fflush(logfile);
		fsync(fileno(logfile));
	}

	callback(destAddr, sourceAddr, protSel, payload, payloadLength);

	return;
}
